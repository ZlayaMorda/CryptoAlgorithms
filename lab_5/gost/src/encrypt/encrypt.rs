pub fn encrypt_block(mut block_low: u32,mut block_high: u32, key: &[u32]) -> (u32, u32) {
    for index in 0..24 {
        (block_low, block_high) = main_round(block_low, block_high, key[index%8]);
    }
    for index in (0..8).rev(){
        (block_low, block_high) = main_round(block_low, block_high, key[index%8]);
    }
    (block_high, block_low)
}

fn main_round(mut block_low: u32, block_high: u32, key: u32) -> (u32, u32) {
    let block_low_clone = block_low;
    block_low ^= key;
    for i in 0..8 {
        let value_to_change = get_4_bits(&block_low, (i * 4) as u8) as usize;
        set_4_bits(
            &mut block_low,
            S_BOX[i][value_to_change],
            (i * 4) as u8
        );
    }
    block_low = ((block_low >> 11) | (block_low << (32 - 11))) & 0xFFFFFFFF;
    block_low ^= block_high;

    (block_low, block_low_clone)
}

fn set_4_bits(u32_val: &mut u32, u4_val: u8, position: u8) {
    *u32_val &= !(0b1111 << position);
    *u32_val |= (u4_val as u32) << position;
}

fn get_4_bits(u32_val: &u32, position: u8) -> u32 {
        let mask = 0b1111 << position;
        (u32_val & mask) >> position
}

const S_BOX: [[u8; 16]; 8] = [
    [0x01, 0x0B, 0x0C, 0x02, 0x09, 0x0D, 0x00, 0x0F, 0x04, 0x05, 0x08, 0x0E, 0x0A, 0x07, 0x06, 0x03],
    [0x00, 0x01, 0x07, 0x0D, 0x0B, 0x04, 0x05, 0x02, 0x08, 0x0E, 0x0F, 0x0C, 0x09, 0x0A, 0x06, 0x03],
    [0x08, 0x02, 0x05, 0x00, 0x04, 0x09, 0x0F, 0x0A, 0x03, 0x07, 0x0C, 0x0D, 0x06, 0x0E, 0x01, 0x0B],
    [0x03, 0x06, 0x00, 0x01, 0x05, 0x0D, 0x0A, 0x08, 0x0B, 0x02, 0x09, 0x07, 0x0E, 0x0F, 0x0C, 0x04],
    [0x08, 0x0D, 0x0B, 0x00, 0x04, 0x05, 0x01, 0x02, 0x09, 0x03, 0x0C, 0x0E, 0x06, 0x0F, 0x0A, 0x07],
    [0x0C, 0x09, 0x0B, 0x01, 0x08, 0x0E, 0x02, 0x04, 0x07, 0x03, 0x06, 0x05, 0x0A, 0x00, 0x0F, 0x0D],
    [0x0A, 0x09, 0x06, 0x08, 0x0D, 0x0E, 0x02, 0x00, 0x0F, 0x03, 0x05, 0x0B, 0x04, 0x01, 0x0C, 0x07],
    [0x07, 0x04, 0x00, 0x05, 0x0A, 0x02, 0x0F, 0x0E, 0x0C, 0x06, 0x01, 0x0B, 0x0D, 0x09, 0x03, 0x08],
];